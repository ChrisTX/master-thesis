\documentclass[../thesis.tex]{subfiles}

\begin{document}
\chapter{Numerical results for the control problem}
In \cref{sec:st-numerics} we presented various numerical approaches for the optimal control problems analyzed in \cref{sec:Disc-Control-Problem}.
The methods were implemented by the author and we want to show numerical results in this chapter.
Before exhibiting said results, we want to discuss how they were implemented.

The implementation at hand works for two space dimensions and one time dimension, rendering $Q$ an overall three dimensional domain.
Therefore, the discontinuous Galerkin method operates on tetrahedral meshes.

In order to generate these meshes, a uniform refinement approach was made. The starting mesh was generated by working with prisms to cover $Q$. This way, if the space domain $\Omega$ can be decomposed into triangles, one can cover the space-time domain $Q$ using prisms based on those triangles.
One can quickly verify that a prism can be decomposed into three tetrahedrons. Overall, this approach permits a flexible mesh generation for this problem if one can represent $\Omega$ using triangles.
However, special attention has to be paid when gluing these prisms together to a tetrahedral mesh, as each face of a prism will consist out of two triangles and these must match the next prism in order to obtain a conformal mesh.

Starting from the mesh generated like this, a uniform refinement approach was made to obtain a finer mesh. It would of course be possible to use an adaptive refinement as well, the discontinuous Galerkin method from \cref{sec:dG-method} permits such.
However, it's not clear how an adaptive refinement would be best approached, as one needs to use the same ansatz space $\Shp(\meshT_N)$ for both the state and the adjoint state, at least if one wants to operate in a fashion that is backed by theory. Therefore, any adaptive refinement would have to account for the errors encountered in both the state and the adjoint state at the same time.

In order to ensure that the refined mesh does not become degenerate - keep the strong dependence of mesh specific constants in the error estimates from \cref{sec:dG-numerics} in mind - one has to use a refinement algorithm that ensures such.
The choice employed for this implementation stems from \cite{Bey}. As we only want to use uniform refinements, the algorithm \verb+RegularRefinement+ defined in \cite[p.\ 361]{Bey} is the choice that was made.
For this algorithm, one can show that the refined tetrahedrons belong to at most three congruence classes, see \cite[Theorem  1, p.\ 361]{Bey} for this statement and its proof.
Combined with the generation of the initial mesh, one can see that this approach will result in a total amount of congruence classes of at most nine times the congruence classes of the initial triangulation:
The prism associated with each triangle is decomposed into three tetrahedrons that in turn will yield at most three congruence classes each.
The work \cite{Bey} also incorporates an algorithm that can handle adaptive refinement, which with one could extend this implementation.

As a next step, we have to define a suitable basis $\{ \varphi_j \}_{j=1}^m$ for $\Shp(\meshT_N)$. By employing the common approach of using a reference tetrahedron and an affine linear map, we can obtain such a basis that is a nodal one over that.
One can easily calculate such a map, see also \cite[p.\ 254]{JungLanger}.
Our goal is to be able to use both linear and quadratic bases.
Establishing a nodal basis on the reference tetrahedron can be manually done by picking a number of points on the reference tetrahedron and calculating functions that fit the requirements. The results of such a calculation can be found in \cite[Tabelle 4.4, p.\ 257]{JungLanger}.

Moreover, one needs numerical integration formulas, so that the integrals that appear in $A(\cdot, \cdot)$ can be evaluated. This holds especially true given that the right hand side of \cref{eq:dg-discrete-prob} depends on the specific input of boundary and initial conditions, which do not have to be functions of $\Shp(\meshT_N)$ of course.
A variety of suitable integration formulas for tetrahedral elements is given in \cite[Tabelle 4.15, p.\ 314]{JungLanger}. For the interface terms appearing in $A(\cdot, \cdot)$ we will also need integration formulas for triangles, see \cite[Tabelle 4.14, p.\ 313]{JungLanger} for possible choices.
Either way, we need to integrate the terms of $A(\cdot, \cdot)$ in an exact fashion if we want to apply the theoretical results from \cref{sec:Disc-Control-Problem}. This means that if we denote by $p$ the polynomial degree which $\Shp(\meshT_N)$ uses per element, we need to integrate on the tetrahedrons functions of degree $2p - 2$ for $a^\sip$ and $2p - 1$ for $b$. On the interfaces we need exact precision for polynomial degree $2p$ for all of $a^\sip$, $a^R$ and $b$.
Hence, we can select the following formulas from \cite{JungLanger}:
\begin{itemize}
\item For linear basis functions: ``3DT-1'' on the tetrahedrons, exact for polynomial degree $1 = 2 \cdot 1 - 1$. ``2DD-3'' or ``2DD-4'' on the triangular interfaces, exact for polynomial degree $2 = 2 \cdot 1$.
\item For quadratic basis functions: ``3DT-4'' on the tetrahedrons, exact for polynomial degree $5 > 2 \cdot 2 - 1$. ``2DD-6'' on the triangular interfaces, exact for polynomial degree $5 > 2 \cdot 2$.
\end{itemize}

Furthermore, we need to select a linear equation solver to solve the discretized problem.
One could either use an iterative method, where the minimal residual algorithm ``MINRES'', see \cite{MINRES}, would be the first choice for the unconstrained control case discussed in \cref{sec:num-unconstrained}.
For the constrained control case, the generalized minimal residual method ``GMRES'' or its flexible variant ``FGMRES'' are possible choices. See \cite{GMRES} for the derivation of ``GMRES'' and \cite{FGMRES} for ``FGMRES''.
Of course, one might also use ``GMRES'' based solvers for the symmetric case.
The implementation at hand supports the ``FGMRES'' from the \cite{MKL} package.
Alternatively, because the discontinuous Galerkin system is expected to become very sparse, one could employ a direct sparse solver.
The software ``PARDISO'' is a flexible and powerful choice for this purpose, see \cite{pardiso1,pardiso2,pardiso3}.
An optimized version of ``PARDISO'' is being shipped as part of the \cite{MKL} software package and supported by the implemented used here.

Finally, a visualization software is needed in order to display the results of the implementation.
The author used the visualization toolkit ``VTK'' (see \cite{VTK}) was used to produce output that can be processed by the ``ParaView'' software (see \cite{ParaView}).
\end{document}